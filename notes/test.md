# CPU_TEST

为了保证 CPU 可正确执行所设的每一条指令，需要对各个指令进行测试，通过观察寄存器与内存中的值来判断指令是否被正确执行。

## q1：内存中的指令如何写入？

在完整的 SOC 中，CPU 通过总线与内存进行连接，同时连接硬盘、ROM BIOS 等设备，在开机时 ROM BIOS 将代码映射到内存中（0x0fff0 - 0x100000），然后 pc 指针从 0x0fff0 开始执行代码，包括检查内存、键盘、显示器、软硬磁盘等设备是否能正常工作。接着，由于在磁盘中存放整个操作系统，在执行完 bios 中的代码后，若未发生错误，则将硬盘中的代码存入 0x7c00 开始执行操作系统。

在此，我们设计了较为简单的 CPU 与内存，并未加入总线的连接，因此在 CPU 执行之前，通过直接对内存进行写入指令而不通过 bios，简化测试流程。

## q2：指令的测试顺序？

通用寄存器最初是全零状态，在 RV32I 中，为了保证指令集的精简，没有 MOV 指令（将立即数直接写入通用寄存器），而是通过 ADD 指令来实现，因此可以先利用 ADD 将寄存器中写入值，再判断其余指令是否能被正确执行。

- 首先执行 ADDI 指令，利用 ADDI 将 imm 写入 gpr：

由于要重复执行多次相似指令，在此利用宏定义：

``` verilog 
`define test_spm_write_OP_IMM(ADDR,imm,rs1,funct3,rd)\
        test_spm_as_ = 0;\
        test_spm_rw = `WRITE;\
        @(posedge clk);\
        #1 begin\
            test_spm_addr = ADDR;\
            test_spm_wr_data = {imm,rs1,funct3,rd,`OP_IMM};\
        end
```

每次需要输入 spm（在此当作内存使用）地址（相当于 pc）以及在 ADDI 中的立即数的大小，gpr 寄存器的访问地址（rs1）和写入地址（rd）。

``` verilog
`test_spm_write_OP_IMM(0,12'b0000_0000_0000,5'b11111,`FUNCT3_ADDI,5'b00000)
`test_spm_write_OP_IMM(4,12'b0000_0000_0001,5'b11111,`FUNCT3_ADDI,5'b00001)
`test_spm_write_OP_IMM(8,12'b0000_0000_0010,5'b11111,`FUNCT3_ADDI,5'b00010)
`test_spm_write_OP_IMM(12,12'b0000_0000_0011,5'b11111,`FUNCT3_ADDI,5'b00011)
`test_spm_write_OP_IMM(16,12'b0000_0000_0100,5'b11111,`FUNCT3_ADDI,5'b00100)
`test_spm_write_OP_IMM(20,12'b0000_0000_0101,5'b11111,`FUNCT3_ADDI,5'b00101)
`test_spm_write_OP_IMM(24,12'b0000_0000_0110,5'b11111,`FUNCT3_ADDI,5'b00110)
`test_spm_write_OP_IMM(28,12'b0000_0000_0111,5'b11111,`FUNCT3_ADDI,5'b00111)
`test_spm_write_OP_IMM(32,12'b0000_0000_1000,5'b11111,`FUNCT3_ADDI,5'b01000)
`test_spm_write_OP_IMM(36,12'b0000_0000_1001,5'b11111,`FUNCT3_ADDI,5'b01001)
`test_spm_write_OP_IMM(40,12'b0000_0000_1010,5'b11111,`FUNCT3_ADDI,5'b01010)
```

如上代码表示，spm 写入有效，在 spm 的 $0$ 地址写入指令，在指令中的立即数为 12'b0000_0000_0000，指令中 gpr 的访问地址为 5'b1111_1（由于寄存器一开始有复位，每一个地址内的值均为0），gpr 写入地址为 5'b0000_0。同理，将 寄存器0 - 寄存器10 写入了 0 - 10。

- 此时 gpr 中有了值，可以执行其余操作，在此先测试余下的 ALU_OP：
  
  先测试 ALU_OP_SLTI，同样利用上述宏定义

每次需要输入 spm（在此当作内存使用）地址（相当于 pc）以及在 ADDI 中的立即数的大小，gpr 寄存器的访问地址（rs1）和写入地址（rd）。

``` verilog
`test_spm_write_OP_IMM(44,12'b0000_0000_0011,5'b00001,`FUNCT3_SLTI,5'b01011)
```

在此，将立即数 $3$ 与 寄存器1 的值进行比较，若 寄存器11 内的值为1，说明 SLTI 执行正确。

而要确认 寄存器11 的值，需要对其进行访问，接着通过 ADDI 来判断

``` verilog
`test_spm_write_OP_IMM(48,12'b0000_0000_0000,5'b01011,`FUNCT3_ADDI,5'b01100)
```

此时 alu 的输出即为 寄存器11 的值。



## ps
1. gpr是否能同时读写？能
2. 单周期ADD如何实现，首先要对 gpr 进行读操作，此后立即将运算结果 alu_out 写入gpr？是的，要注意的是读写地址不能相同，因为写入的值由读出的值计算得到，会导致循环执行。
3. we_ 是什么信号，到底是gpr使能还是gpr读写信号？是否写信号，gpr 一直都可以被读，只有当 we_ 为低电平时才发生写。

4. 在实例化时，一个端口与多个端口连接，在内部定义一个 signal，利用 assign signal = ()? : ; 实现。

5. 避免出现 inout 信号，弄清楚各个信号的逻辑关系（即谁得到谁）。

6. 充分利用宏定义简化代码。

7. 有符号数和无符号数运算：（1）在进行加法、乘法运算时需要进行扩展位，对于无符号数（高位补符号位，即正数补0，负数补1）；对于无符号数默认高位补零。（2）在进行位移操作时，对于算数左移、逻辑位移的有符号数与无符号数一样补零；而对于算数右移，有符号数补符号位，无符号数补零。（3）reg  signed [7:0]a; 定义有符号数，$signed() 进行无符号数与有符号数的转换。